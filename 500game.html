<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neon particle watch · connected dots</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0b0b1f;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: 'Arial', sans-serif;
    }

    .watch-container {
      background: rgba(5, 5, 15, 0.7);
      backdrop-filter: blur(4px);
      border-radius: 3rem 3rem 4rem 4rem;
      padding: 2.2rem 2.8rem;
      box-shadow: 0 0 40px rgba(0, 255, 255, 0.4), inset 0 0 20px rgba(180, 0, 255, 0.3);
      border: 1px solid rgba(0, 255, 255, 0.4);
    }

    canvas {
      display: block;
      width: 700px;
      height: 300px;
      border-radius: 2rem;
      background: radial-gradient(circle at 20% 30%, #14142b, #020210);
      box-shadow: 0 0 60px #00ffff88, 0 0 20px #ff66ff99;
      cursor: default;
      margin: 0 auto;
    }

    .label {
      text-align: center;
      margin-top: 1.2rem;
      font-size: 1.2rem;
      letter-spacing: 6px;
      text-transform: uppercase;
      color: #b0f0ff;
      text-shadow: 0 0 8px cyan, 0 0 16px magenta;
      font-weight: 300;
    }
  </style>
</head>
<body>
<div class="watch-container">
  <canvas id="clockCanvas" width="700" height="300"></canvas>
  <div class="label">✦ 粒子数字 · 连点时空 ✦</div>
</div>

<script>
  (function() {
    const canvas = document.getElementById('clockCanvas');
    const ctx = canvas.getContext('2d');

    // ----------  neon color palette ----------
    const neonPalette = [
      '#00ffff', // cyan
      '#ff44ff', // magenta
      '#aaf0ff', // light cyan
      '#ffaa00', // electric orange
      '#b0ff90', // mint
      '#ff99cc'  // soft pink
    ];

    // ----------  digit patterns (7-segment like, but dot matrix style) ----------
    // each digit is 5x7 grid (5 cols, 7 rows) – true = dot present
    const digitMatrix = {
      0: [
        [0,1,1,1,0],
        [1,0,0,0,1],
        [1,0,0,1,1],
        [1,0,1,0,1],
        [1,1,0,0,1],
        [1,0,0,0,1],
        [0,1,1,1,0]
      ],
      1: [
        [0,0,1,0,0],
        [0,1,1,0,0],
        [1,0,1,0,0],
        [0,0,1,0,0],
        [0,0,1,0,0],
        [0,0,1,0,0],
        [1,1,1,1,1]
      ],
      2: [
        [0,1,1,1,0],
        [1,0,0,0,1],
        [0,0,0,0,1],
        [0,0,1,1,0],
        [0,1,0,0,0],
        [1,0,0,0,0],
        [1,1,1,1,1]
      ],
      3: [
        [1,1,1,1,1],
        [0,0,0,0,1],
        [0,0,0,1,0],
        [0,1,1,1,0],
        [0,0,0,0,1],
        [1,0,0,0,1],
        [0,1,1,1,0]
      ],
      4: [
        [1,0,0,0,1],
        [1,0,0,0,1],
        [1,0,0,0,1],
        [1,1,1,1,1],
        [0,0,0,0,1],
        [0,0,0,0,1],
        [0,0,0,0,1]
      ],
      5: [
        [1,1,1,1,1],
        [1,0,0,0,0],
        [1,1,1,1,0],
        [0,0,0,0,1],
        [0,0,0,0,1],
        [1,0,0,0,1],
        [0,1,1,1,0]
      ],
      6: [
        [0,1,1,1,0],
        [1,0,0,0,1],
        [1,0,0,0,0],
        [1,1,1,1,0],
        [1,0,0,0,1],
        [1,0,0,0,1],
        [0,1,1,1,0]
      ],
      7: [
        [1,1,1,1,1],
        [0,0,0,0,1],
        [0,0,0,1,0],
        [0,0,1,0,0],
        [0,1,0,0,0],
        [0,1,0,0,0],
        [0,1,0,0,0]
      ],
      8: [
        [0,1,1,1,0],
        [1,0,0,0,1],
        [1,0,0,0,1],
        [0,1,1,1,0],
        [1,0,0,0,1],
        [1,0,0,0,1],
        [0,1,1,1,0]
      ],
      9: [
        [0,1,1,1,0],
        [1,0,0,0,1],
        [1,0,0,0,1],
        [0,1,1,1,1],
        [0,0,0,0,1],
        [1,0,0,0,1],
        [0,1,1,1,0]
      ]
    };

    // colon (2 dots vertically) for separator
    function drawColon(x, y, dotSpacing, radius, color) {
      // two dots at row 2 and 4 (zero-indexed)
      const colonRows = [2, 4];
      for (let r of colonRows) {
        const cy = y + r * dotSpacing;
        ctx.beginPath();
        ctx.arc(x, cy, radius * 1.1, 0, 2 * Math.PI);
        ctx.fillStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = 20;
        ctx.fill();
      }
    }

    // draw one digit (5x7) at top-left (startX, startY), each dot spaced by "step"
    function drawDigit(digit, startX, startY, step, dotRadius, baseColor) {
      const matrix = digitMatrix[digit];
      if (!matrix) return;

      for (let row = 0; row < 7; row++) {
        for (let col = 0; col < 5; col++) {
          if (matrix[row][col] === 1) {
            const x = startX + col * step;
            const y = startY + row * step;
            ctx.beginPath();
            ctx.arc(x, y, dotRadius, 0, 2 * Math.PI);
            ctx.fillStyle = baseColor;
            ctx.shadowColor = baseColor;
            ctx.shadowBlur = 24;
            ctx.fill();
          }
        }
      }
    }

    // ----- function to connect nearby dots (distance based) -----
    function connectDots(positions, maxDist, lineColor, thin = false) {
      if (positions.length < 2) return;
      ctx.save();
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = thin ? 0.8 : 1.5;
      ctx.shadowBlur = 20;
      ctx.shadowColor = lineColor;
      ctx.beginPath();
      for (let i = 0; i < positions.length; i++) {
        for (let j = i + 1; j < positions.length; j++) {
          const dx = positions[i].x - positions[j].x;
          const dy = positions[i].y - positions[j].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < maxDist) {
            ctx.moveTo(positions[i].x, positions[i].y);
            ctx.lineTo(positions[j].x, positions[j].y);
          }
        }
      }
      ctx.stroke();
      ctx.restore();
    }

    // ----- main drawing routine -----
    function drawNeonParticleWatch() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // get current time (hours, minutes, seconds)
      const now = new Date();
      let hours = now.getHours();
      const minutes = now.getMinutes();
      const seconds = now.getSeconds();

      // format as two-digit strings
      const hh = hours.toString().padStart(2, '0');
      const mm = minutes.toString().padStart(2, '0');
      const ss = seconds.toString().padStart(2, '0');

      // drawing parameters
      const dotSpacing = 24;            // distance between grid points
      const dotRadius = 7;              // base dot size
      const startY = 60;                 // top margin

      // positions of first digit (leftmost) — layout: 2 digits + colon + 2 digits + colon + 2 digits
      const firstX = 60;
      const digitWidth = 5 * dotSpacing;    // each digit 5 columns
      const colonXOffset = 2 * dotSpacing;   // extra after digit
      const interDigitGap = 22;              // space between digit blocks

      // predefine colors (change per digit group)
      const colorH = neonPalette[0]; // cyan
      const colorM = neonPalette[1]; // magenta
      const colorS = neonPalette[2]; // light cyan / white mix
      const colonColor = neonPalette[3]; // orange

      // Collect all dot positions for connection (later)
      let allDotPositions = [];

      // ---- helper to add digit dot positions to array ----
      function captureDigitPositions(digit, startX, startY, step, positionsArray) {
        const matrix = digitMatrix[digit];
        if (!matrix) return;
        for (let row = 0; row < 7; row++) {
          for (let col = 0; col < 5; col++) {
            if (matrix[row][col] === 1) {
              const x = startX + col * step;
              const y = startY + row * step;
              positionsArray.push({ x, y });
            }
          }
        }
      }

      // ---- draw digits + capture positions ----

      // hours (first digit)
      const h1 = parseInt(hh[0], 10);
      const h2 = parseInt(hh[1], 10);
      drawDigit(h1, firstX, startY, dotSpacing, dotRadius, colorH);
      captureDigitPositions(h1, firstX, startY, dotSpacing, allDotPositions);

      const secondDigitX = firstX + digitWidth + interDigitGap;
      drawDigit(h2, secondDigitX, startY, dotSpacing, dotRadius, colorH);
      captureDigitPositions(h2, secondDigitX, startY, dotSpacing, allDotPositions);

      // colon after hours
      const colon1X = secondDigitX + digitWidth + interDigitGap * 0.8;
      drawColon(colon1X, startY, dotSpacing, dotRadius * 0.9, colonColor);
      // colon dots add to positions for connection? (optional, yes for more nodes)
      allDotPositions.push({ x: colon1X, y: startY + 2 * dotSpacing });
      allDotPositions.push({ x: colon1X, y: startY + 4 * dotSpacing });

      // minutes
      const m1 = parseInt(mm[0], 10);
      const m2 = parseInt(mm[1], 10);
      const minuteStartX = colon1X + interDigitGap;
      drawDigit(m1, minuteStartX, startY, dotSpacing, dotRadius, colorM);
      captureDigitPositions(m1, minuteStartX, startY, dotSpacing, allDotPositions);

      const minuteSecondX = minuteStartX + digitWidth + interDigitGap;
      drawDigit(m2, minuteSecondX, startY, dotSpacing, dotRadius, colorM);
      captureDigitPositions(m2, minuteSecondX, startY, dotSpacing, allDotPositions);

      // second colon
      const colon2X = minuteSecondX + digitWidth + interDigitGap * 0.8;
      drawColon(colon2X, startY, dotSpacing, dotRadius * 0.9, colonColor);
      allDotPositions.push({ x: colon2X, y: startY + 2 * dotSpacing });
      allDotPositions.push({ x: colon2X, y: startY + 4 * dotSpacing });

      // seconds
      const s1 = parseInt(ss[0], 10);
      const s2 = parseInt(ss[1], 10);
      const secondStartX = colon2X + interDigitGap;
      drawDigit(s1, secondStartX, startY, dotSpacing, dotRadius, colorS);
      captureDigitPositions(s1, secondStartX, startY, dotSpacing, allDotPositions);

      const secondSecondX = secondStartX + digitWidth + interDigitGap;
      drawDigit(s2, secondSecondX, startY, dotSpacing, dotRadius, colorS);
      captureDigitPositions(s2, secondSecondX, startY, dotSpacing, allDotPositions);

      // --- additional floating dots to enrich space (optional sparkles) ---
      function addRandomDots(baseArray, count, minX, maxX, minY, maxY) {
        for (let i = 0; i < count; i++) {
          const x = Math.random() * (maxX - minX) + minX;
          const y = Math.random() * (maxY - minY) + minY;
          baseArray.push({ x, y });
        }
      }
      // add a few background dots (they will also connect, giving extra sparkle)
      addRandomDots(allDotPositions, 18, 40, 660, 30, 270);

      // ---- connection pass: draw lines between nearby dots ----
      // use a max distance of 60 pixels for soft neon connections
      // glow colors vary: use a blend of cyan/magenta
      connectDots(allDotPositions, 58, '#b0f0ff', true);   // thin cyan connections
      connectDots(allDotPositions, 42, '#ff80ff', false);  // thicker magenta for closer dots

      // ---- extra: draw central dots again with strong glow to emphasize ----
      for (let p of allDotPositions) {
        // use variable colors based on position (just for fun)
        const gradient = ctx.createRadialGradient(p.x-2, p.y-2, 2, p.x, p.y, 14);
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(0.6, neonPalette[Math.floor(Math.random() * neonPalette.length)]);
        ctx.beginPath();
        ctx.arc(p.x, p.y, dotRadius * 0.9, 0, 2 * Math.PI);
        ctx.fillStyle = gradient;
        ctx.shadowBlur = 32;
        ctx.shadowColor = '#ff66ff';
        ctx.fill();
      }

      // tiny digital labels (optional)
      ctx.shadowBlur = 0;
      ctx.font = '10px "Arial", sans-serif';
      ctx.fillStyle = '#88aaff';
      ctx.fillText('⚡ neon particle mesh', 520, 280);
    }

    // animate every second (update time)
    function updateClock() {
      drawNeonParticleWatch();
      requestAnimationFrame(updateClock);
    }

    // initial draw
    drawNeonParticleWatch();
    // refresh each second (since time changes)
    setInterval(() => {
      drawNeonParticleWatch();
    }, 1000);
  })();
</script>
</body>
</html>