<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>digital clock // particles // seconds</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        #canvas { position: absolute; top: 0; left: 0; z-index: 1; }
        .ui {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: #888;
            pointer-events: none;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 2px;
            z-index: 2;
            text-shadow: 0 0 5px rgba(255,255,255,0.3);
        }
        .time-fallback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 6rem;
            font-weight: bold;
            opacity: 0.03;
            pointer-events: none;
            white-space: nowrap;
            z-index: 0;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="ui">⌛ seconds alive // drag to distort // 500 -> clock</div>
    <div class="time-fallback" id="fallbackTime">00:00:00</div>

    <script>
        (function() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const fallbackEl = document.getElementById('fallbackTime');

            let points = [];
            const mouse = { x: -1000, y: -1000, radius: 160 };
            let animationFrame;
            let lastTimeString = '';

            // --- resize + init ---
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                // re-generate points based on current time
                generatePointsFromClock();
            }

            // --- generate particle grid from current time text ---
            function generatePointsFromClock() {
                // get current time with seconds (HH:MM:SS)
                const now = new Date();
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                const seconds = now.getSeconds().toString().padStart(2, '0');
                const timeStr = `${hours}:${minutes}:${seconds}`;  // format 00:00:00
                lastTimeString = timeStr;
                fallbackEl.textContent = timeStr; // keep the ghost behind

                // clear canvas, draw big text, sample points
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // use a monospace bold font for consistent spacing
                const fontSize = Math.min(200, canvas.width * 0.15);
                ctx.font = `bold ${fontSize}px 'Courier New', monospace`;
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(timeStr, canvas.width / 2, canvas.height / 2);

                // get pixel data
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                ctx.clearRect(0, 0, canvas.width, canvas.height); // clean for animation

                const newPoints = [];
                const step = 6; // sampling step (smaller = more particles)

                for (let y = 0; y < canvas.height; y += step) {
                    for (let x = 0; x < canvas.width; x += step) {
                        const index = (y * canvas.width + x) * 4;
                        // if pixel is not transparent (alpha > 0)
                        if (imageData.data[index + 3] > 128) {
                            newPoints.push({
                                x: x, y: y,
                                originX: x, originY: y,
                                vx: 0, vy: 0
                            });
                        }
                    }
                }

                points = newPoints;
            }

            // --- update clock every second (and regenerate points) ---
            function updateClock() {
                const now = new Date();
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                const seconds = now.getSeconds().toString().padStart(2, '0');
                const currentTime = `${hours}:${minutes}:${seconds}`;

                // if time string changed, regenerate particles
                if (currentTime !== lastTimeString) {
                    // to avoid flickering during resize/regeneration, we keep old points while building new?
                    // but we want smooth transition — we can instantly replace points.
                    // we also need to store new origin positions
                    const prevPoints = points; // optional, but we just regenerate fresh
                    
                    // clear and redraw text offscreen to sample
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const fontSize = Math.min(200, canvas.width * 0.15);
                    ctx.font = `bold ${fontSize}px 'Courier New', monospace`;
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(currentTime, canvas.width / 2, canvas.height / 2);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    ctx.clearRect(0, 0, canvas.width, canvas.height); // restore clean

                    const newPoints = [];
                    const step = 6;
                    for (let y = 0; y < canvas.height; y += step) {
                        for (let x = 0; x < canvas.width; x += step) {
                            const index = (y * canvas.width + x) * 4;
                            if (imageData.data[index + 3] > 128) {
                                newPoints.push({
                                    x: x, y: y,
                                    originX: x, originY: y,
                                    vx: 0, vy: 0
                                });
                            }
                        }
                    }

                    // smoothly? we can just assign, but maybe preserve velocities? 
                    // for simplicity, we assign new points (the old ones disappear)
                    // but that may look abrupt. we could morph by matching? 
                    // keep it simple: replace. but for a more organic feel,
                    // we'll only replace if the new set is not empty, and reset velocities.
                    if (newPoints.length > 100) { // safety
                        points = newPoints;
                    }
                    
                    lastTimeString = currentTime;
                    fallbackEl.textContent = currentTime;
                }
            }

            // --- animation loop ---
            function animate() {
                // every frame: draw particles, handle mouse repulsion, spring back
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // faint connecting lines style
                ctx.strokeStyle = 'rgba(100, 180, 255, 0.12)';
                ctx.lineWidth = 0.8;

                // update and draw each point
                for (let i = 0; i < points.length; i++) {
                    const p = points[i];

                    // mouse interaction
                    const dx = mouse.x - p.x;
                    const dy = mouse.y - p.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < mouse.radius) {
                        const angle = Math.atan2(dy, dx);
                        const force = (mouse.radius - dist) / mouse.radius;
                        // push away (negative direction) — so subtract from velocity
                        const repelStrength = 4.2;
                        p.vx -= Math.cos(angle) * force * repelStrength;
                        p.vy -= Math.sin(angle) * force * repelStrength;
                    }

                    // spring force back to origin
                    const spring = 0.06;
                    p.vx += (p.originX - p.x) * spring;
                    p.vy += (p.originY - p.y) * spring;

                    // friction
                    p.vx *= 0.92;
                    p.vy *= 0.92;

                    p.x += p.vx;
                    p.y += p.vy;

                    // draw point with slight glow / variation
                    const brightness = 0.8 + 0.4 * Math.sin(p.x * 0.01 + p.y * 0.01 + Date.now() * 0.002);
                    ctx.fillStyle = `rgba(210, 230, 255, ${brightness})`;
                    ctx.fillRect(p.x, p.y, 1.8, 1.8);

                    // draw lines to some neighbours (skip many for performance, but give a web effect)
                    // we connect only every few points and limit distance
                    for (let j = i + 1; j < points.length; j += 17) { 
                        const p2 = points[j];
                        const dx2 = p.x - p2.x;
                        const dy2 = p.y - p2.y;
                        const dist2 = Math.sqrt(dx2*dx2 + dy2*dy2);
                        if (dist2 < 48 && dist2 > 0) {
                            ctx.beginPath();
                            ctx.moveTo(p.x, p.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.stroke();
                        }
                    }
                }

                animationFrame = requestAnimationFrame(animate);
            }

            // --- mouse tracking ---
            window.addEventListener('mousemove', (e) => {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
            });

            window.addEventListener('mouseleave', () => {
                mouse.x = -1000;
                mouse.y = -1000;
            });

            // touch support for mobile (simple)
            window.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length) {
                    mouse.x = e.touches[0].clientX;
                    mouse.y = e.touches[0].clientY;
                }
            }, { passive: false });

            window.addEventListener('touchend', () => {
                mouse.x = -1000;
                mouse.y = -1000;
            });

            // --- keep clock accurate, re-generate points each second ---
            setInterval(() => {
                updateClock();
            }, 200); // check every 200ms to catch second change quickly, but only regenerate on actual change

            // also regenerate on resize (with debounce)
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    resizeCanvas();
                }, 150);
            });

            // initial start
            resizeCanvas();  // sets points for current time
            animate();

            // edge: if page hidden, no need to generate, but fine
            // also ensure fallback style not intrusive
            fallbackEl.style.opacity = '0.03';
        })();
    </script>
</body>
</html>